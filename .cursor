# Ascended Social - Cursor AI Rules
# Spiritual Social Media Platform Development Guidelines

## üßò Project Overview
You are working on Ascended Social, a mystical social media platform that merges spirituality with technology. This is a full-stack TypeScript application with React frontend, Express backend, and comprehensive spiritual features including chakra-based content categorization, AI oracle readings, 3D Starmap visualization, and cross-platform mobile support.

## üèóÔ∏è Architecture & Tech Stack

### Core Technologies
- **Frontend**: React 18 + TypeScript + Vite + Tailwind CSS + shadcn/ui
- **Backend**: Node.js + Express + TypeScript + Drizzle ORM
- **Database**: PostgreSQL (Neon serverless)
- **Authentication**: Replit Auth (OpenID Connect) + Passport.js
- **Mobile**: React Native + Expo with cross-platform sync
- **AI Integration**: OpenAI GPT-4 for spiritual content analysis
- **Payments**: Stripe for premium subscriptions
- **Storage**: Google Cloud Storage + Replit Object Storage
- **Testing**: Vitest + Playwright + Cypress + Chromatic
- **Documentation**: Notion API + MCP integration + Storybook

### Project Structure
```
/
‚îú‚îÄ‚îÄ client/                 # React frontend (Vite + TypeScript)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/    # React components (shadcn/ui based)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/         # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/         # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/         # Utility functions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stories/       # Storybook stories
‚îú‚îÄ‚îÄ server/                # Express backend (TypeScript)
‚îÇ   ‚îú‚îÄ‚îÄ routes/            # API route handlers
‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # Express middleware
‚îÇ   ‚îú‚îÄ‚îÄ services/          # Business logic services
‚îÇ   ‚îî‚îÄ‚îÄ types/             # TypeScript type definitions
‚îú‚îÄ‚îÄ shared/                # Shared types and utilities
‚îÇ   ‚îî‚îÄ‚îÄ schema.ts          # Drizzle schema definitions
‚îî‚îÄ‚îÄ docs/                  # Documentation
    ‚îú‚îÄ‚îÄ developer/         # Technical documentation
    ‚îú‚îÄ‚îÄ user/             # User guides
    ‚îî‚îÄ‚îÄ styling/          # Design system docs
```

## üé® Spiritual Design System

### Chakra-Based Color System
Always use the seven chakra colors for spiritual categorization:
- **Root Chakra**: `#dc2626` (red) - Grounding, survival, security
- **Sacral Chakra**: `#ea580c` (orange) - Creativity, sexuality, emotions
- **Solar Plexus**: `#d97706` (yellow) - Personal power, confidence, will
- **Heart Chakra**: `#16a34a` (green) - Love, compassion, relationships
- **Throat Chakra**: `#2563eb` (blue) - Communication, expression, truth
- **Third Eye**: `#7c3aed` (indigo) - Intuition, insight, wisdom
- **Crown Chakra**: `#8b5cf6` (violet) - Spirituality, enlightenment, connection

### Spiritual UI Principles
- **Harmony**: Consistent design language across all components
- **Balance**: Light and dark themes representing spiritual duality
- **Flow**: Smooth animations and transitions for mindful interactions
- **Authenticity**: Components that serve spiritual growth over engagement metrics
- **Mystical Aesthetics**: Cosmic themes, sacred geometry, and spiritual symbolism

## üîß Development Guidelines

### TypeScript Best Practices
- **Strict Type Safety**: Use strict TypeScript configuration
- **Shared Types**: Define types in `shared/schema.ts` for consistency
- **Interface Naming**: Use descriptive names (e.g., `SpiritualPost`, `ChakraType`, `AuraLevel`)
- **Generic Types**: Use generics for reusable spiritual components
- **Type Guards**: Implement proper type checking for spiritual data

### React Component Guidelines
- **Functional Components**: Use React hooks and functional components
- **Props Interface**: Always define TypeScript interfaces for component props
- **Spiritual Props**: Include spiritual-specific props (chakra, aura, energy)
- **Accessibility**: Ensure all components are accessible (ARIA labels, keyboard navigation)
- **Performance**: Use React.memo, useMemo, and useCallback for optimization

### API Development
- **RESTful Design**: Follow REST conventions for API endpoints
- **Spiritual Endpoints**: Use meaningful names (`/api/oracle/readings`, `/api/energy/share`)
- **Authentication**: Always validate Replit Auth tokens
- **Error Handling**: Return consistent error responses with spiritual context
- **Rate Limiting**: Implement appropriate rate limiting for spiritual features

### Database Schema
- **Drizzle ORM**: Use Drizzle for all database operations
- **Spiritual Tables**: Include spiritual-specific columns (chakra_type, aura_level, energy_points)
- **Relationships**: Properly define relationships between spiritual entities
- **Migrations**: Use `npm run db:push` for schema changes

## üåü Spiritual Feature Development

### Chakra System
```typescript
type ChakraType = 'root' | 'sacral' | 'solar_plexus' | 'heart' | 'throat' | 'third_eye' | 'crown';

interface ChakraData {
  type: ChakraType;
  color: string;
  frequency: number;
  description: string;
  associatedElements: string[];
}
```

### Energy System
- **Energy Points**: Monthly refreshing energy for premium engagements
- **Energy Sharing**: Users can share energy with posts and comments
- **Energy Visualization**: Show energy flow in UI components
- **Energy History**: Track energy usage and sharing patterns

### Oracle System
- **AI Integration**: Use OpenAI GPT-4 for spiritual readings
- **Personalized Content**: Base readings on user behavior and preferences
- **Chakra Analysis**: Analyze content for chakra alignment
- **Spiritual Frequency**: Calculate spiritual resonance scores

### 3D Starmap Visualization
- **React Three Fiber**: Use Three.js for 3D visualizations
- **Spiritual Nodes**: Represent users as celestial bodies
- **Energy Connections**: Show spiritual connections between users
- **Interactive Controls**: Implement touch and mouse controls
- **Performance**: Optimize for mobile and desktop rendering

## üì± Mobile Development

### Cross-Platform Considerations
- **React Native**: Use Expo for cross-platform development
- **Deep Linking**: Implement deep links for mobile authentication
- **Platform Detection**: Detect mobile vs web platforms
- **Sync Strategy**: Implement real-time sync between web and mobile
- **Offline Support**: Cache spiritual content for offline access

### Mobile-Specific Features
- **Push Notifications**: OneSignal for spiritual reminders
- **Native Modules**: Use native modules for advanced 3D visualization
- **Platform UI**: Adapt UI for iOS and Android while maintaining spiritual aesthetic
- **Performance**: Optimize for mobile performance and battery life

## üß™ Testing Strategy

### Test Categories
- **Unit Tests**: Test individual functions and components
- **Integration Tests**: Test API endpoints and database operations
- **E2E Tests**: Test complete user journeys with Playwright
- **Visual Tests**: Use Chromatic for visual regression testing
- **Spiritual Tests**: Test chakra classification and oracle accuracy

### Testing Tools
- **Vitest**: Unit and component testing
- **Playwright**: End-to-end testing
- **Cypress**: Component testing
- **Chromatic**: Visual regression testing
- **Browserless**: Production monitoring and testing

## üìö Documentation & Sync

### Notion Integration
- **Auto-Sync**: Use MCP integration for automatic documentation sync
- **Mobile Docs**: Sync mobile-specific documentation
- **API Docs**: Keep API documentation up to date
- **User Guides**: Maintain user-facing documentation

### Code Documentation
- **JSDoc**: Document all functions and components
- **README Files**: Maintain clear README files for each module
- **Type Comments**: Add comments to complex TypeScript types
- **Spiritual Context**: Explain spiritual significance of features

## üîê Security & Compliance

### Authentication & Authorization
- **Replit Auth**: Use OpenID Connect for authentication
- **JWT Tokens**: Implement secure token management
- **Session Management**: Use PostgreSQL for session storage
- **Role-Based Access**: Implement proper authorization checks

### Privacy & GDPR
- **Data Protection**: Implement GDPR compliance
- **Consent Management**: Use Enzuzo for consent management
- **Data Export**: Provide user data export functionality
- **Privacy by Design**: Build privacy into all features

### Security Best Practices
- **Input Validation**: Validate all user inputs
- **SQL Injection**: Use parameterized queries with Drizzle
- **XSS Protection**: Sanitize user-generated content
- **CSRF Protection**: Implement CSRF tokens
- **Rate Limiting**: Implement appropriate rate limiting

## üöÄ Performance & Optimization

### Frontend Performance
- **Code Splitting**: Use dynamic imports for route-based splitting
- **Image Optimization**: Optimize images for spiritual content
- **Caching**: Implement proper caching strategies
- **Bundle Size**: Monitor and optimize bundle size

### Backend Performance
- **Database Queries**: Optimize database queries with Drizzle
- **Caching**: Implement Redis caching for frequently accessed data
- **API Response**: Optimize API response times
- **Error Handling**: Implement proper error handling and logging

### Mobile Performance
- **Bundle Size**: Optimize React Native bundle size
- **Native Performance**: Use native modules for performance-critical features
- **Memory Management**: Implement proper memory management
- **Battery Optimization**: Optimize for battery life

## üéØ Development Workflow

### Daily Workflow
1. **Morning Setup**: Check Notion docs, sync latest changes
2. **Feature Development**: Build features using spiritual design system
3. **Testing**: Run comprehensive tests for all changes
4. **Documentation**: Update documentation and sync to Notion
5. **Code Review**: Review code for spiritual context and technical quality

### Feature Development Process
1. **Design**: Create spiritual UI designs in Figma
2. **Sync**: Extract design tokens via MCP integration
3. **Develop**: Implement features with TypeScript and React
4. **Test**: Write and run comprehensive tests
5. **Document**: Update documentation and sync to Notion
6. **Deploy**: Deploy with proper monitoring and health checks

### Code Quality Standards
- **TypeScript**: Strict type checking enabled
- **ESLint**: Use ESLint for code quality
- **Prettier**: Use Prettier for code formatting
- **Husky**: Use Git hooks for pre-commit checks
- **Spiritual Context**: Always consider spiritual significance of features

## üåà Spiritual Development Principles

### Code as Sacred Practice
- **Mindful Coding**: Write code with intention and awareness
- **Spiritual Context**: Consider the spiritual impact of every feature
- **Community Focus**: Build features that serve the spiritual community
- **Authentic Growth**: Prioritize genuine spiritual development over engagement metrics

### Feature Development Philosophy
- **User-Centric**: Always consider the spiritual user experience
- **Community Building**: Foster authentic spiritual connections
- **Personal Growth**: Support individual spiritual development
- **Harmony**: Maintain balance between technology and spirituality

## üîß Environment Setup

### Required Environment Variables
```bash
# Database
DATABASE_URL=postgresql://...

# Authentication
REPLIT_CLIENT_ID=your_replit_client_id
REPLIT_CLIENT_SECRET=your_replit_client_secret

# AI Integration
OPENAI_API_KEY=your_openai_api_key

# Payments
STRIPE_SECRET_KEY=your_stripe_secret_key
STRIPE_PUBLISHABLE_KEY=your_stripe_publishable_key

# Storage
GOOGLE_CLOUD_STORAGE_BUCKET=your_bucket_name
GOOGLE_CLOUD_PROJECT_ID=your_project_id

# Notion Integration
NOTION_INTEGRATION_SECRET=your_notion_secret
NOTION_PAGE_ID=your_notion_page_id

# Analytics
POSTHOG_API_KEY=your_posthog_key
POSTHOG_HOST=https://app.posthog.com

# Notifications
ONESIGNAL_APP_ID=your_onesignal_app_id
ONESIGNAL_API_KEY=your_onesignal_api_key
```

### Development Commands
```bash
# Start development server
npm run dev

# Build for production
npm run build

# Run tests
npm run test:all

# Database operations
npm run db:push

# Storybook
npm run storybook

# Sync documentation
npm run sync:docs
```

## üé® Design System Integration

### Figma MCP Integration
- **Design Tokens**: Extract chakra colors and spiritual spacing
- **Component Specs**: Sync component specifications
- **Bidirectional Updates**: Enable real-time design-code sync
- **Spiritual Elements**: Focus on mystical and cosmic design elements

### Storybook Documentation
- **Component Stories**: Document all spiritual components
- **Interactive Examples**: Show component variations
- **Accessibility Testing**: Test component accessibility
- **Spiritual Context**: Explain spiritual significance of components

## üö® Common Pitfalls to Avoid

### Technical Pitfalls
- **Type Safety**: Don't use `any` types, always define proper interfaces
- **Performance**: Don't forget to optimize for mobile and 3D rendering
- **Security**: Always validate inputs and implement proper authentication
- **Testing**: Don't skip tests, especially for spiritual features

### Spiritual Context Pitfalls
- **Authenticity**: Don't gamify spiritual features excessively
- **Community**: Don't prioritize engagement metrics over genuine connection
- **Respect**: Always respect the spiritual nature of the platform
- **Balance**: Maintain balance between technology and spirituality

## üìû Support & Resources

### Internal Resources
- **Notion Workspace**: Comprehensive project documentation
- **Storybook**: Component library and examples
- **API Documentation**: Complete API reference
- **Design System**: Spiritual design guidelines

### External Resources
- **React Documentation**: Official React guides
- **TypeScript Handbook**: TypeScript best practices
- **Drizzle ORM**: Database ORM documentation
- **Three.js**: 3D visualization library
- **OpenAI API**: AI integration documentation

---

**Remember**: You are building a platform that serves spiritual growth and community connection. Every line of code should reflect this purpose and contribute to the authentic spiritual experience of our users. üßò‚ú®

**Last Updated**: January 2024  
**Version**: 1.0.0  
**Project**: Ascended Social - Spiritual Social Media Platform
